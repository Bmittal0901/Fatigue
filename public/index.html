<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fatigue Detection Typing Test</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&family=Space+Grotesk:wght@400;600&display=swap" rel="stylesheet">
    <style>
        /* Your existing CSS here */
        :root {
            --primary-color: #36a3ff; /* A vibrant blue */
            --secondary-color: #50E3C2; /* A fresh teal */
            --background-light: #F8F9FA; /* Off-white for body background */
            --panel-bg: #ffffff; /* Solid white for panels */
            --text-dark: #343a40; /* Darker text for better contrast */
            --border-color-light: #e9ecef; /* Light border for subtle separation */
            --shadow-subtle: 0 4px 15px rgba(0,0,0,0.08);
            --border-radius-base: 0.8rem; /* Slightly larger radius for softness */
            --border-radius-sm: 0.5rem;
        }

        body {
            background: linear-gradient(to bottom right, var(--background-light), #ffffff);
            font-family: 'Space Grotesk', 'Inter', sans-serif;
            color: var(--text-dark);
            min-height: 100vh; /* Ensure body takes full height */
            display: flex; /* Use flex to center content if needed */
            align-items: center; /* Vertically center main container */
            padding: 1.5rem 0; /* Add some vertical padding */
        }

        .container-fluid {
            max-width: 1400px; /* Max width for the main content area */
            margin: auto; /* Center the container */
        }

        .sidebar, .main-panel, .control-panel {
            background-color: var(--panel-bg);
            box-shadow: var(--shadow-subtle);
            padding: 2rem; /* Increased padding for more breathing room */
            min-height: 700px; /* Minimum height for consistency */
            overflow-y: auto;
            border-radius: var(--border-radius-base);
            border: 1px solid var(--border-color-light); /* Subtle border */
            display: flex; /* Flex container for better layout within panels */
            flex-direction: column;
        }

        /* Adjust specific panel heights for better balance */
        .main-panel {
            min-height: 700px; /* Ensure main typing area is tall enough */
        }
        .sidebar {
            min-height: 700px;
        }
        .control-panel {
            min-height: 700px;
        }

        h4, h5 {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 1.5rem; /* More space below headings */
        }

        textarea {
            height: 180px; /* Slightly taller textarea */
            border-radius: var(--border-radius-sm);
            border: 1px solid var(--border-color-light);
            padding: 1rem;
            font-size: 1.1rem; /* Slightly larger font in textarea */
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            resize: vertical; /* Allow vertical resizing, but limit min height */
            min-height: 100px;
        }
        textarea:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.25rem rgba(var(--primary-color), .25); /* Custom focus ring */
            outline: none; /* Remove default outline */
        }

        .metrics-box {
            background-color: var(--background-light); /* Light background for metrics */
            border-radius: var(--border-radius-sm);
            padding: 1.25rem;
            margin-bottom: 1.5rem;
            border: 1px solid var(--border-color-light); /* Subtle border */
        }
        .metrics-box label {
            font-weight: 500; /* Slightly bolder labels */
            color: var(--text-dark);
            margin-bottom: 0.2rem; /* Space between label and value */
            display: block; /* Ensure labels are block elements */
        }
        .metrics-box span {
            display: block;
            font-weight: bold;
            font-size: 1.5rem; /* Larger font for metric values */
            color: var(--primary-color);
            margin-bottom: 1rem; /* Space after each value */
        }

        .form-label {
            font-weight: 500;
            color: var(--text-dark);
            margin-bottom: 0.5rem; /* Space below labels */
        }
        .form-control, .form-select {
            border-radius: var(--border-radius-sm);
            border: 1px solid var(--border-color-light);
            padding: 0.6rem 0.75rem; /* Slightly more padding */
            font-size: 0.95rem;
        }
        .form-control:focus, .form-select:focus {
            border-color: var(--primary-color);
            box-shadow: 0 0 0 0.25rem rgba(var(--primary-color), .25);
            outline: none;
        }

        .form-label.required::after {
            content: " *";
            color: #dc3545; /* Bootstrap red */
        }

        .fade-in {
            animation: fadeIn 0.6s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        button {
            border-radius: var(--border-radius-sm);
            padding: 0.75rem 1.25rem; /* More prominent buttons */
            font-size: 1rem;
            transition: all 0.2s ease-in-out;
        }
        button:hover {
            transform: translateY(-2px); /* Lift effect on hover */
            box-shadow: 0 6px 12px rgba(0,0,0,0.1);
        }

        .btn-primary {
            background-color: var(--primary-color);
            border-color: var(--primary-color);
        }
        .btn-primary:hover {
            background-color: #2a8ae6; /* Slightly darker primary on hover */
            border-color: #2a8ae6;
        }

        .btn-success {
            background-color: var(--secondary-color);
            border-color: var(--secondary-color);
            color: var(--text-dark); /* Ensure text is readable on light teal */
        }
        .btn-success:hover {
            background-color: #40cfa9; /* Slightly darker secondary on hover */
            border-color: #40cfa9;
        }

        .btn-outline-secondary {
            border-color: var(--border-color-light);
            color: var(--text-dark);
        }
        .btn-outline-secondary:hover {
            background-color: var(--border-color-light);
            border-color: var(--border-color-light);
            color: var(--text-dark);
        }
        .btn-outline-danger {
            border-color: #dc3545;
            color: #dc3545;
        }
        .btn-outline-danger:hover {
            background-color: #dc3545;
            color: #ffffff;
        }

        #statusLabel {
            font-weight: 700; /* Bolder status label */
            font-size: 1.3rem; /* Larger font */
            color: var(--primary-color); /* Primary color for success */
            margin-top: 1.5rem; /* More space above */
        }
        #statusLabel.text-danger {
            color: #dc3545; /* Red for errors */
        }

        .progress {
            height: 12px; /* Thicker progress bar */
            border-radius: 6px;
            background-color: var(--border-color-light); /* Lighter background for empty part */
        }
        .progress-bar {
            background: var(--primary-color);
            transition: width 0.4s ease-in-out;
        }

        #metricsDisplay {
            margin-top: 1.5rem; /* More space above */
            background-color: var(--background-light);
            border-radius: var(--border-radius-sm);
            padding: 1.25rem;
            border: 1px solid var(--border-color-light);
        }
        #metricsDisplay b {
            display: inline-block;
            width: 130px; /* Slightly wider for alignment */
            font-weight: 600;
            color: var(--primary-color); /* Labels in primary color */
        }

        /* Styling for when typing area is disabled */
        #typingArea[disabled] {
            background-color: #f1f4f6; /* A clear disabled background */
            cursor: not-allowed;
            opacity: 0.8;
        }

        /* Responsive adjustments */
        @media (max-width: 991px) {
            .sidebar, .main-panel, .control-panel {
                min-height: auto; /* Allow height to adjust on smaller screens */
                margin-bottom: 1.5rem; /* Add space between stacked panels */
            }
            body {
                padding: 1rem 0; /* Less padding on smaller screens */
                display: block; /* Revert to block layout for stacking */
            }
        }
        @media (max-width: 767px) {
            .sidebar, .main-panel, .control-panel {
                padding: 1rem; /* Smaller padding on very small screens */
            }
            h4, h5 {
                font-size: 1.3rem;
                margin-bottom: 1rem;
            }
            textarea {
                height: 120px;
                font-size: 1rem;
            }
            .metrics-box span {
                font-size: 1.2rem;
            }
            button {
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }
        }
    </style>
</head>
<body>

<div class="container-fluid">
    <div class="row g-3">
        <div class="col-md-3 sidebar">
            <h5 class="mb-4"><i class="fas fa-user-circle me-2"></i> Participant Info</h5>
            <div class="mb-3">
                <label for="username" class="form-label required">Name</label>
                <input type="text" id="username" class="form-control" required placeholder="Enter your name" minlength="2">
            </div>
            <div class="mb-3">
                <label for="ageGroup" class="form-label required">Age Group</label>
                <select id="ageGroup" class="form-select" required>
                    <option value="">Select</option>
                    <option>Under 18</option>
                    <option>18–25</option>
                    <option>26–35</option>
                    <option>36–50</option>
                    <option>51+</option>
                </select>
            </div>
            <div class="mb-3">
                <label for="gender" class="form-label required">Gender</label>
                <select id="gender" class="form-select" required>
                    <option value="">Select</option>
                    <option>Male</option>
                    <option>Female</option>
                    <option>Other</option>
                    <option>Prefer not to say</option>
                </select>
            </div>
            <div class="mb-3">
                <label for="typingSkill" class="form-label required">Typing Skill</label>
                <select id="typingSkill" class="form-select" required>
                    <option value="">Select</option>
                    <option>Beginner</option>
                    <option>Intermediate</option>
                    <option>Advanced</option>
                </select>
            </div>
            <div class="mb-3">
                <label for="occupation" class="form-label required">Occupation</label>
                <input type="text" id="occupation" class="form-control" required placeholder="e.g., Student, Engineer">
            </div>
            <div class="mb-3">
                <label for="typingHours" class="form-label required">Typing Hours (Daily)</label>
                <select id="typingHours" class="form-select" required>
                    <option value="">Select</option>
                    <option>&lt;1</option>
                    <option>1–2</option>
                    <option>2–4</option>
                    <option>4–6</option>
                    <option>6+</option>
                </select>
            </div>
            <div class="mb-3">
                <label for="mentalFatigue" class="form-label">Mental Fatigue (0–5): <span id="mentalFatigueValue">0</span></label>
                <input type="range" id="mentalFatigue" class="form-range" min="0" max="5" value="0" oninput="document.getElementById('mentalFatigueValue').innerText = this.value">
            </div>
            <div class="mb-4">
                <label for="physicalFatigue" class="form-label">Physical Fatigue (0–5): <span id="physicalFatigueValue">0</span></label>
                <input type="range" id="physicalFatigue" class="form-range" min="0" max="5" value="0" oninput="document.getElementById('physicalFatigueValue').innerText = this.value">
            </div>
            <button class="btn btn-primary w-100 mt-auto" onclick="submitDemographics()"><i class="fas fa-play me-2"></i> Start Test</button>
        </div>

        <div class="col-md-6 main-panel fade-in">
            <h4 class="mb-4">⌨️ Typing Test</h4>
            <p id="typingSentence" class="fs-5 fw-semibold text-muted mb-4">Loading sentences, please wait...</p>
            <textarea id="typingArea" class="form-control" disabled placeholder="Your typing area..."></textarea>
            <div class="progress my-4">
                <div id="progressBar" class="progress-bar" role="progressbar" style="width: 0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100"></div>
            </div>
            <p class="text-end fw-semibold text-muted" id="progressText">Corpus loading...</p>
            <div class="d-grid gap-2 mt-4">
                <button class="btn btn-success" onclick="submitSentence()"><i class="fas fa-check-circle me-2"></i> Submit Sentence</button>
            </div>
            <div class="text-center mt-3" id="statusLabel"></div>
            <div class="mt-4" id="metricsDisplay" style="display:none;"></div>
        </div>

        <div class="col-md-3 control-panel">
            <h5 class="mb-4"><i class="fas fa-chart-line me-2"></i> Live Analytics</h5>
            <div class="metrics-box">
                <label>Live WPM</label>
                <span id="liveWpm">0</span>
                <label>Error %</label>
                <span id="liveError">0%</span>
                <label>Avg IKI (ms)</label>
                <span id="liveIki">0</span>
                <label>KSPC</label>
                <span id="liveKspc">0</span>
                <label>Backspaces</label>
                <span id="liveBackspace">0</span>
            </div>
            <hr class="my-4">
            <div class="d-grid gap-2 mt-auto">
                <button class="btn btn-outline-secondary" onclick="downloadSummaryCSV()"><i class="fas fa-download me-2"></i> Download Full Log (CSV)</button>
                <button class="btn btn-outline-danger" onclick="clearAllSummaries()"><i class="fas fa-trash-alt me-2"></i> Clear All Logs</button>
            </div>
        </div>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
<script>
    // Firebase Configuration
    const firebaseConfig = {
        apiKey: "AIzaSyDU56-FribrzudeFeh1-gz7ch25HHoWAGk", // REPLACE WITH YOUR ACTUAL API KEY
        authDomain: "fatiguedetection-e13a1.firebaseapp.com",
        databaseURL: "https://fatiguedetection-e13a1-default-rtdb.firebaseio.com",
        projectId: "fatiguedetection-e13a1",
        storageBucket: "fatiguedetection-e13a1.appspot.com",
        messagingSenderId: "239129487774",
        appId: "1:239129487774:web:e6ceb32ddbaea27a7a8e8f"
    };
    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const database = firebase.database();
</script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.6.0/dist/confetti.browser.min.js"></script>
<script>
    let allCorpusSentences = []; // This will hold all sentences loaded from the corpus file
    const NUM_SENTENCES_PER_TEST = 10; // Fixed number of sentences per test

    let username = "";
    let currentTestSentences = []; // This will hold the 10 sentences for the current test
    let index = 0; // Current sentence index within currentTestSentences
    let logs = []; // Logs for the current test session (individual sentences)
    let keystrokes = 0; // Total keystrokes for the current sentence
    let backspaces = 0; // Total backspaces for the current sentence
    let delays = []; // Array of inter-key intervals (IKIs) for the current sentence
    let lastKeyTime = 0; // Timestamp of the last key press
    let startTime = 0; // Timestamp when the user starts typing the current sentence
    let testActive = false; // Flag to indicate if a test is in progress

    const typingArea = document.getElementById("typingArea");
    const statusLabel = document.getElementById("statusLabel");
    const metricsDisplay = document.getElementById("metricsDisplay");
    const progressTextElement = document.getElementById("progressText"); // Get the element


    // --- New Function: Load Corpus ---
    async function loadCorpus(filePath) {
        try {
            const response = await fetch(filePath);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const text = await response.text();
            // Split by newline, filter out empty lines, and trim whitespace
            allCorpusSentences = text.split('\n').map(s => s.trim()).filter(s => s.length > 0);
            console.log(`Loaded ${allCorpusSentences.length} sentences from corpus.`);
            progressTextElement.innerText = `Sentence 0 of ${NUM_SENTENCES_PER_TEST}`; // Update after loading
        } catch (error) {
            console.error("Error loading corpus:", error);
            statusLabel.classList.add('text-danger');
            statusLabel.innerText = "❌ Failed to load sentences corpus. Check console (F12).";
            // Optionally, disable the start button if corpus loading fails critically
            document.querySelector('button[onclick="submitDemographics()"]').disabled = true;
        }
    }

    // Call loadCorpus when the script loads (or when the DOM is ready)
    document.addEventListener('DOMContentLoaded', () => {
        // IMPORTANT: Use the correct file name you generated
        loadCorpus('filtered_sentences_8_10_words.txt');
    });


    // Event listener for keydown on the typing area
    typingArea.addEventListener("keydown", e => {
        if (!testActive) return;

        const now = performance.now();

        // Start timer on the first actual character typed, ignoring modifiers/function keys
        if (startTime === 0 && (e.key.length === 1 || e.key === " ")) {
            startTime = now;
        }

        // Prevent common navigation/editing keys from moving cursor
        const blockedKeys = ["ArrowLeft", "ArrowRight", "ArrowUp", "ArrowDown", "Home", "End", "Delete"];
        if (blockedKeys.includes(e.key)) {
            e.preventDefault();
            return;
        }

        if (e.key.length === 1 || e.key === " ") { // Count regular characters and space
            keystrokes++;
        } else if (e.key === "Backspace") {
            backspaces++;
            keystrokes++; // Backspace is also a keystroke
        }

        if (lastKeyTime > 0) {
            delays.push(now - lastKeyTime);
        }
        lastKeyTime = now;

        // Keep cursor at the end (for consistency with locked-cursor behavior)
        setTimeout(() => {
            typingArea.selectionStart = typingArea.selectionEnd = typingArea.value.length;
        }, 0);
    });

    // Ensure cursor stays at the end during input
    typingArea.addEventListener('input', () => {
        if (!testActive) return;
        typingArea.selectionStart = typingArea.selectionEnd = typingArea.value.length;
        updateLiveMetrics();
    });

    // Ensure cursor is at the end when the textarea gains focus
    typingArea.addEventListener('focus', () => {
        typingArea.selectionStart = typingArea.selectionEnd = typingArea.value.length;
    });


    // --- Helper function to shuffle an array (Fisher-Yates algorithm) ---
    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }


    function updateUI() {
        document.getElementById("typingSentence").innerText = currentTestSentences[index];
        progressTextElement.innerText = `Sentence ${index + 1} of ${NUM_SENTENCES_PER_TEST}`;
        document.getElementById("progressBar").style.width = `${((index + 1) / NUM_SENTENCES_PER_TEST) * 100}%`; // +1 because it's current sentence not completed
        document.getElementById("progressBar").setAttribute('aria-valuenow', ((index + 1) / NUM_SENTENCES_PER_TEST) * 100);

        typingArea.disabled = false;
        typingArea.readOnly = false; // Ensure it's writable
        typingArea.value = ""; // Clear previous text
        typingArea.focus(); // Focus for immediate typing

        // Reset metrics for the new sentence
        keystrokes = 0;
        backspaces = 0;
        delays = [];
        startTime = 0;
        lastKeyTime = 0;

        // Reset live metrics display to 0 or default
        updateLiveMetrics({
            wpm: 0,
            error: "0%",
            iki: 0,
            kspc: 0,
            backspaces: 0,
            initial: true // Flag to signal initial reset
        });

        // Prevent text selection (optional, for a cleaner UI)
        typingArea.style.userSelect = "none";
        // Disable autocorrect, autocapitalize, and spellcheck for a raw typing experience
        typingArea.setAttribute("autocorrect", "off");
        typingArea.setAttribute("autocapitalize", "off");
        typingArea.setAttribute("spellcheck", "false");

        // Ensure cursor is at the end after UI update
        setTimeout(() => {
            typingArea.selectionStart = typingArea.selectionEnd = typingArea.value.length;
            typingArea.scrollIntoView({
                behavior: "smooth",
                block: "center"
            });
        }, 200);
    }

    // Function to load and select sentences for the current test
    function loadUserProgress() {
        username = document.getElementById("username").value.trim();
        if (!username) return;

        index = 0; // Reset sentence index
        logs = []; // Clear previous logs

        // Check if there are enough sentences in the corpus
        if (allCorpusSentences.length < NUM_SENTENCES_PER_TEST) {
            statusLabel.classList.remove('text-success');
            statusLabel.classList.add('text-danger');
            statusLabel.innerText = `🚨 Not enough sentences in corpus. Need ${NUM_SENTENCES_PER_TEST}, but found ${allCorpusSentences.length}. Please add more sentences to filtered_sentences_8_10_words.txt.`;
            // Re-enable start button if an error occurs here
            document.querySelector('button[onclick="submitDemographics()"]').disabled = false;
            testActive = false; // Ensure test does not start
            typingArea.disabled = true; // Keep typing area disabled
            return;
        }

        // Create a copy to shuffle, so the original corpus isn't modified
        const shuffledSentences = [...allCorpusSentences];
        shuffleArray(shuffledSentences);

        // Select the first NUM_SENTENCES_PER_TEST sentences
        currentTestSentences = shuffledSentences.slice(0, NUM_SENTENCES_PER_TEST);
        console.log("Selected sentences for this test:", currentTestSentences);
        
        // Start the test
        testActive = true;
        updateUI(); // Display the first sentence
        statusLabel.classList.remove('text-danger');
        statusLabel.classList.add('text-success');
        statusLabel.innerText = "Test started!";
        metricsDisplay.style.display = 'block'; // Show metrics once test starts
    }

    function submitDemographics() {
        // Ensure corpus is loaded before starting the test
        if (allCorpusSentences.length === 0) {
            statusLabel.classList.remove('text-success');
            statusLabel.classList.add('text-danger');
            statusLabel.innerText = "🚨 Sentences are still loading or failed to load. Please wait or refresh.";
            return;
        }

        const u = document.getElementById("username").value.trim();
        const ageGroup = document.getElementById("ageGroup").value;
        const gender = document.getElementById("gender").value;
        const typingSkill = document.getElementById("typingSkill").value;
        const occupation = document.getElementById("occupation").value.trim();
        const typingHours = document.getElementById("typingHours").value;
        const mentalFatigue = document.getElementById("mentalFatigue").value;
        const physicalFatigue = document.getElementById("physicalFatigue").value;

        if (!u || !ageGroup || !gender || !typingSkill || !occupation || !typingHours) {
            statusLabel.classList.remove('text-success');
            statusLabel.classList.add('text-danger');
            statusLabel.innerText = "🚨 Please fill in all required fields.";
            return;
        }

        username = u;
        document.querySelector('button[onclick="submitDemographics()"]').disabled = true; // Disable start button

        loadUserProgress(); // This will select the 10 random sentences and start the test
    }


    function calculateWPM(typedText, originalText, timeTakenSeconds) {
        const originalWords = originalText.split(/\s+/).filter(word => word.length > 0);
        const typedWords = typedText.split(/\s+/).filter(word => word.length > 0);

        let correctWords = 0;
        for (let i = 0; i < Math.min(originalWords.length, typedWords.length); i++) {
            if (originalWords[i] === typedWords[i]) {
                correctWords++;
            }
        }
        
        const charactersTyped = typedText.length;
        const grossWPM = (charactersTyped / 5) / (timeTakenSeconds / 60);

        let errors = 0;
        for (let i = 0; i < Math.max(originalText.length, typedText.length); i++) {
            if (originalText[i] !== typedText[i]) {
                errors++;
            }
        }
        const errorPercentage = (errors / originalText.length) * 100;

        return {
            grossWPM: isNaN(grossWPM) ? 0 : Math.round(grossWPM),
            errors: errors,
            errorPercentage: isNaN(errorPercentage) ? 0 : errorPercentage.toFixed(2)
        };
    }

    function calculateIKI() {
        if (delays.length === 0) return 0;
        const sum = delays.reduce((a, b) => a + b, 0);
        return Math.round(sum / delays.length); // Average IKI in milliseconds
    }

    function calculateKSPC(typedText, originalText) {
        // KSPC (Keystrokes Per Character) - ideally 1.0 if no errors/backspaces
        // total_keystrokes / length_of_original_sentence
        if (originalText.length === 0) return 0;
        return (keystrokes / originalText.length).toFixed(2);
    }

    function updateLiveMetrics(initialReset = false) {
        if (initialReset) {
            document.getElementById("liveWpm").innerText = 0;
            document.getElementById("liveError").innerText = "0%";
            document.getElementById("liveIki").innerText = 0;
            document.getElementById("liveKspc").innerText = 0;
            document.getElementById("liveBackspace").innerText = 0;
            return;
        }

        const typedText = typingArea.value;
        const originalText = currentTestSentences[index];
        const currentTime = performance.now();
        const timeTakenSeconds = (currentTime - startTime) / 1000;

        if (timeTakenSeconds > 0) {
            const { grossWPM, errorPercentage } = calculateWPM(typedText, originalText, timeTakenSeconds);
            const avgIKI = calculateIKI();
            const kspc = calculateKSPC(typedText, originalText);

            document.getElementById("liveWpm").innerText = grossWPM;
            document.getElementById("liveError").innerText = `${errorPercentage}%`;
            document.getElementById("liveIki").innerText = avgIKI;
            document.getElementById("liveKspc").innerText = kspc;
            document.getElementById("liveBackspace").innerText = backspaces;
        } else {
            // If no time has passed yet, keep live metrics at 0
            document.getElementById("liveWpm").innerText = 0;
            document.getElementById("liveError").innerText = "0%";
            document.getElementById("liveIki").innerText = 0;
            document.getElementById("liveKspc").innerText = 0;
            document.getElementById("liveBackspace").innerText = 0;
        }
    }


    function submitSentence() {
        if (!testActive) {
            statusLabel.classList.add('text-danger');
            statusLabel.innerText = "Test not started. Please fill in demographics and click 'Start Test'.";
            return;
        }

        if (startTime === 0) {
            statusLabel.classList.add('text-danger');
            statusLabel.innerText = "Please start typing before submitting the sentence.";
            return;
        }

        const originalSentence = currentTestSentences[index];
        const typedSentence = typingArea.value;
        const endTime = performance.now();
        const timeTaken = (endTime - startTime) / 1000; // in seconds

        const { grossWPM, errors, errorPercentage } = calculateWPM(typedSentence, originalSentence, timeTaken);
        const avgIKI = calculateIKI();
        const kspc = calculateKSPC(typedSentence, originalSentence);

        const currentLog = {
            sentenceIndex: index + 1,
            originalSentence: originalSentence,
            typedSentence: typedSentence,
            timeTakenSeconds: timeTaken.toFixed(2),
            grossWPM: grossWPM,
            errors: errors,
            errorPercentage: errorPercentage,
            avgIKI_ms: avgIKI,
            kspc: kspc,
            backspaces: backspaces,
            timestamp: new Date().toISOString()
        };
        logs.push(currentLog);
        console.log("Sentence Log:", currentLog);

        index++; // Move to the next sentence

        if (index < NUM_SENTENCES_PER_TEST) {
            updateUI(); // Load next sentence
            statusLabel.classList.remove('text-danger');
            statusLabel.classList.add('text-success');
            statusLabel.innerText = "Sentence submitted. Next sentence loaded!";
        } else {
            endTest(); // All sentences completed
        }
    }

    function endTest() {
        testActive = false;
        typingArea.disabled = true;
        typingArea.value = "";
        document.getElementById("typingSentence").innerText = "Test Complete!";
        statusLabel.classList.remove('text-danger');
        statusLabel.classList.add('text-success');
        statusLabel.innerText = "🎉 Test finished! Generating summary...";
        document.getElementById("progressBar").style.width = `100%`;
        document.getElementById("progressBar").setAttribute('aria-valuenow', 100);
        progressTextElement.innerText = `Test Complete!`;

        // Combine demographics with full test logs
        const finalData = {
            participantInfo: {
                username: username,
                ageGroup: document.getElementById("ageGroup").value,
                gender: document.getElementById("gender").value,
                typingSkill: document.getElementById("typingSkill").value,
                occupation: document.getElementById("occupation").value,
                typingHours: document.getElementById("typingHours").value,
                mentalFatigue: document.getElementById("mentalFatigue").value,
                physicalFatigue: document.getElementById("physicalFatigue").value,
            },
            testLogs: logs,
            testStartTime: logs[0] ? logs[0].timestamp : new Date().toISOString(), // First sentence's timestamp
            testEndTime: logs[logs.length - 1] ? logs[logs.length - 1].timestamp : new Date().toISOString(), // Last sentence's timestamp
            totalSentences: NUM_SENTENCES_PER_TEST,
            // You might add overall averages here later
        };

        // Save to Firebase
        saveDataToFirebase(finalData);

        // Display overall summary
        displayOverallSummary(finalData);

        // Show confetti for completion!
        confetti({
            particleCount: 100,
            spread: 70,
            origin: { y: 0.6 }
        });
        
        // Re-enable start button
        document.querySelector('button[onclick="submitDemographics()"]').disabled = false;
    }

    function saveDataToFirebase(data) {
        try {
            const userId = username.replace(/[^a-zA-Z0-9]/g, '_') + '_' + Date.now(); // Simple ID for user session
            database.ref('fatigueTests/' + userId).set(data)
                .then(() => {
                    console.log("Data saved to Firebase successfully!");
                    statusLabel.innerText = "✅ Test finished & data saved!";
                })
                .catch((error) => {
                    console.error("Error saving data to Firebase:", error);
                    statusLabel.classList.add('text-danger');
                    statusLabel.innerText = "⚠️ Test finished, but data SAVE FAILED! Check console.";
                });
        } catch (e) {
            console.error("Firebase save function error:", e);
            statusLabel.classList.add('text-danger');
            statusLabel.innerText = "⚠️ Test finished, but Firebase setup error!";
        }
    }

    function displayOverallSummary(finalData) {
        let totalWPM = 0;
        let totalErrorPercentage = 0;
        let totalIKI = 0;
        let totalKSPC = 0;
        let totalBackspaces = 0;
        let validSentences = 0;

        finalData.testLogs.forEach(log => {
            totalWPM += log.grossWPM;
            totalErrorPercentage += parseFloat(log.errorPercentage);
            totalIKI += log.avgIKI_ms;
            totalKSPC += parseFloat(log.kspc);
            totalBackspaces += log.backspaces;
            validSentences++; // Count only logs that were successfully recorded
        });

        const avgWPM = (totalWPM / validSentences).toFixed(0);
        const avgErrorPercentage = (totalErrorPercentage / validSentences).toFixed(2);
        const avgIKI = (totalIKI / validSentences).toFixed(0);
        const avgKSPC = (totalKSPC / validSentences).toFixed(2);
        const totalOverallBackspaces = totalBackspaces;

        let summaryHtml = `
            <h5>Overall Summary</h5>
            <p><b>Average WPM:</b> ${avgWPM}</p>
            <p><b>Average Error %:</b> ${avgErrorPercentage}%</p>
            <p><b>Average IKI (ms):</b> ${avgIKI}</p>
            <p><b>Average KSPC:</b> ${avgKSPC}</p>
            <p><b>Total Backspaces:</b> ${totalOverallBackspaces}</p>
        `;
        metricsDisplay.innerHTML = summaryHtml;
        metricsDisplay.style.display = 'block'; // Ensure it's visible
    }

// Function to download all stored summaries as CSV from Firebase, aggregated per user session
function downloadSummaryCSV() {
    const downloadButton = document.querySelector('button[onclick="downloadSummaryCSV()"]');
    // Change button text to indicate fetching
    downloadButton.disabled = true;
    downloadButton.innerHTML = '<span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span> Fetching Data...';

    // Fetch all data from the 'fatigueTests' path in Firebase
    database.ref('fatigueTests').once('value')
        .then(snapshot => {
            const allAggregatedData = []; // This will store one aggregated row per user session
            
            // Define headers for the aggregated CSV data
            const headers = [
                'Session ID', 'Test Start Time (ISO)', 'Test End Time (ISO)', 'Total Sentences',
                'Username', 'Age Group', 'Gender', 'Typing Skill', 'Occupation',
                'Typing Hours (Daily)', 'Mental Fatigue (0-5)', 'Physical Fatigue (0-5)',
                'Average Gross WPM', 'Average Error Percentage (%)', 'Average Avg IKI (ms)',
                'Average KSPC', 'Total Backspaces' // Total backspaces is a sum, not an average
            ];

            // Iterate through each unique user session (e.g., userId_timestamp)
            snapshot.forEach(userSessionSnapshot => {
                const sessionID = userSessionSnapshot.key; // This is the unique key generated by Firebase
                const sessionData = userSessionSnapshot.val(); // All data for this specific test session

                const participantInfo = sessionData.participantInfo || {};
                const testLogs = sessionData.testLogs || []; // Array of individual sentence logs

                // --- Aggregation Logic for this specific user session ---
                let totalWPM = 0;
                let totalErrorPercentage = 0;
                let totalIKI = 0;
                let totalKSPC = 0;
                let totalBackspaces = 0;
                let validSentenceCount = 0; // To ensure we only average valid logs

                testLogs.forEach(log => {
                    // Ensure values are numbers before adding them to accumulators
                    totalWPM += parseFloat(log.grossWPM || 0);
                    totalErrorPercentage += parseFloat(log.errorPercentage || 0);
                    totalIKI += parseFloat(log.avgIKI_ms || 0);
                    totalKSPC += parseFloat(log.kspc || 0);
                    totalBackspaces += parseInt(log.backspaces || 0);
                    validSentenceCount++;
                });

                // Calculate averages for the session
                const avgWPM = validSentenceCount > 0 ? (totalWPM / validSentenceCount).toFixed(0) : 0;
                const avgErrorPercentage = validSentenceCount > 0 ? (totalErrorPercentage / validSentenceCount).toFixed(2) : 0;
                const avgIKI = validSentenceCount > 0 ? (totalIKI / validSentenceCount).toFixed(0) : 0;
                const avgKSPC = validSentenceCount > 0 ? (totalKSPC / validSentenceCount).toFixed(2) : 0;
                // totalBackspaces is already a sum for the session

                // Construct a single aggregated row for this user session
                const aggregatedRow = {
                    'Session ID': sessionID,
                    'Test Start Time (ISO)': sessionData.testStartTime || '',
                    'Test End Time (ISO)': sessionData.testEndTime || '',
                    'Total Sentences': sessionData.totalSentences || 0, // Should be 10 if test completed
                    'Username': participantInfo.username || '',
                    'Age Group': participantInfo.ageGroup || '',
                    'Gender': participantInfo.gender || '',
                    'Typing Skill': participantInfo.typingSkill || '',
                    'Occupation': participantInfo.occupation || '',
                    'Typing Hours (Daily)': participantInfo.typingHours || '',
                    'Mental Fatigue (0-5)': participantInfo.mentalFatigue || '',
                    'Physical Fatigue (0-5)': participantInfo.physicalFatigue || '',
                    'Average Gross WPM': avgWPM,
                    'Average Error Percentage (%)': avgErrorPercentage,
                    'Average Avg IKI (ms)': avgIKI,
                    'Average KSPC': avgKSPC,
                    'Total Backspaces': totalBackspaces
                };
                allAggregatedData.push(aggregatedRow); // Add this single row to our collection
            });

            if (allAggregatedData.length === 0) {
                alert("No data available in Firebase to download.");
                return;
            }

            // Generate CSV string from the aggregated data
            const csvRows = [
                headers.join(','), // CSV header row
                ...allAggregatedData.map(row => headers.map(header => {
                    let value = row[header];
                    // Handle potential null/undefined values
                    if (value === null || value === undefined) {
                        value = '';
                    }
                    // Sanitize value for CSV: escape double quotes, enclose if contains commas or newlines
                    if (typeof value === 'string') {
                        value = value.replace(/"/g, '""'); // Escape double quotes by doubling them
                        if (value.includes(',') || value.includes('\n')) {
                            return `"${value}"`; // Enclose in double quotes if it contains commas or newlines
                        }
                    }
                    return value;
                }).join(',')) // Join column values with comma for each row
            ];

            const csvString = csvRows.join('\n'); // Join rows with newline characters

            // Create a Blob and trigger the download
            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `fatigue_test_aggregated_data_${new Date().toISOString().slice(0,10)}.csv`; // Filename for the downloaded CSV
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href); // Clean up the object URL to free memory

            alert("Aggregated data downloaded successfully!");

        })
        .catch(error => {
            console.error("Error fetching data from Firebase:", error);
            alert("Failed to download data from Firebase. Check console for details.");
        })
        .finally(() => {
            // Re-enable the button and restore its original text
            downloadButton.disabled = false;
            downloadButton.innerHTML = '<i class="fas fa-download me-2"></i> Download Full Log (CSV)';
        });
}

    function clearAllSummaries() {
        if (confirm("Are you sure you want to clear ALL locally stored logs? This will not clear Firebase data without a specific function for it.")) {
            logs = [];
            console.log("Local logs cleared.");
            statusLabel.classList.remove('text-danger');
            statusLabel.classList.add('text-success');
            statusLabel.innerText = "Local logs cleared!";
            metricsDisplay.style.display = 'none'; // Hide metrics
        }
    }
</script>
</body>
</html>
```
